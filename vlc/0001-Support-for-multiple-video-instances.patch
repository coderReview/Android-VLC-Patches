diff --git a/include/vlc/libvlc_media_player.h b/include/vlc/libvlc_media_player.h
index 9ba313e..f4513c8 100644
--- a/include/vlc/libvlc_media_player.h
+++ b/include/vlc/libvlc_media_player.h
@@ -437,6 +437,23 @@ LIBVLC_API void libvlc_media_player_set_nsobject ( libvlc_media_player_t *p_mi,
 LIBVLC_API void * libvlc_media_player_get_nsobject ( libvlc_media_player_t *p_mi );
 
 /**
+ * Set the android_surface_value_t structure handler holding the Android surface information where
+ * the media player should render its video output.
+ *
+ * \param p_mi the Media Player
+ * \param object the android_surface_value_t structure to set.
+ */
+LIBVLC_API void libvlc_media_player_set_surfacevalue ( libvlc_media_player_t *p_mi, void * object );
+
+/**
+ * Gets a handler to the android_surface_value_t structure holding Android Surface object information.
+ *
+ * \param p_mi the Media Player
+ * \return the android_surface_value_t pointer or 0 if none where set
+ */
+LIBVLC_API void * libvlc_media_player_get_surfacevalue ( libvlc_media_player_t *p_mi );
+
+/**
  * Set the agl handler where the media player should render its video output.
  *
  * \param p_mi the Media Player
diff --git a/lib/media_player.c b/lib/media_player.c
index 64240aa..6f4d87c 100644
--- a/lib/media_player.c
+++ b/lib/media_player.c
@@ -519,6 +519,9 @@ libvlc_media_player_new( libvlc_instance_t *instance )
     var_Create (mp, "drawable-agl", VLC_VAR_INTEGER);
     var_Create (mp, "drawable-nsobject", VLC_VAR_ADDRESS);
 #endif
+#ifdef __ANDROID__
+    var_Create (mp, "drawable-surfacevalue", VLC_VAR_ADDRESS);
+#endif
 
     var_Create (mp, "keyboard-events", VLC_VAR_BOOL);
     var_SetBool (mp, "keyboard-events", true);
@@ -1023,6 +1026,35 @@ void * libvlc_media_player_get_nsobject( libvlc_media_player_t *p_mi )
 #endif
 }
 
+
+/**************************************************************************
+ * set_surfacevalue
+ **************************************************************************/
+void libvlc_media_player_set_surfacevalue( libvlc_media_player_t *p_mi,
+                                           void * object )
+{
+    assert (p_mi != NULL);
+#ifdef __ANDROID__
+    var_SetAddress (p_mi, "drawable-surfacevalue", object);
+#else
+    (void) p_mi; (void)object;
+#endif
+}
+
+/**************************************************************************
+ * get_surfacevalue
+ **************************************************************************/
+void * libvlc_media_player_get_surfacevalue( libvlc_media_player_t *p_mi )
+{
+    assert (p_mi != NULL);
+#ifdef __ANDROID__
+    return var_GetAddress (p_mi, "drawable-surfacevalue");
+#else
+    return NULL;
+#endif
+}
+
+
 /**************************************************************************
  * set_agl
  **************************************************************************/
diff --git a/modules/codec/omxil/android_mediacodec.c b/modules/codec/omxil/android_mediacodec.c
index 44184c6..4ec4ec5 100644
--- a/modules/codec/omxil/android_mediacodec.c
+++ b/modules/codec/omxil/android_mediacodec.c
@@ -49,14 +49,16 @@
 
 #define THREAD_NAME "android_mediacodec"
 
+typedef struct android_surf_value_t android_surf_value_t;
+
 extern int jni_attach_thread(JNIEnv **env, const char *thread_name);
 extern void jni_detach_thread();
 /* JNI functions to get/set an Android Surface object. */
-extern jobject jni_LockAndGetAndroidJavaSurface();
-extern void jni_UnlockAndroidSurface();
-extern void jni_SetAndroidSurfaceSizeEnv(JNIEnv *p_env, int width, int height, int visible_width, int visible_height, int sar_num, int sar_den);
-extern void jni_EventHardwareAccelerationError();
-extern bool jni_IsVideoPlayerActivityCreated();
+extern jobject jni_LockAndGetAndroidJavaSurface(android_surf_value_t *object);
+extern void jni_UnlockAndroidSurface(android_surf_value_t *object);
+extern void jni_SetAndroidSurfaceSizeEnv(android_surf_value_t *object, JNIEnv *p_env, int width, int height, int visible_width, int visible_height, int sar_num, int sar_den);
+extern void jni_EventHardwareAccelerationError(android_surf_value_t *android_surface);
+extern bool jni_IsVideoPlayerActivityCreated(android_surf_value_t *android_surface);
 
 /* Implementation of a circular buffer of timestamps with overwriting
  * of older values. MediaCodec has only one type of timestamp, if a
@@ -173,6 +175,8 @@ struct decoder_sys_t
     picture_t** inflight_picture; /**< stores the inflight picture for each output buffer or NULL */
 
     timestamp_fifo_t *timestamp_fifo;
+
+    android_surf_value_t *object;
 };
 
 enum Types
@@ -326,6 +330,12 @@ static int OpenDecoder(vlc_object_t *p_this)
     if ((p_dec->p_sys = p_sys = calloc(1, sizeof(*p_sys))) == NULL)
         return VLC_ENOMEM;
 
+    p_sys->object = var_CreateGetAddress (p_dec, "drawable-surfacevalue");
+    if (!p_sys->object) {
+        msg_Warn(p_dec, "No android_surf_value_t set.");
+        return VLC_EGENERIC;
+    }
+
     p_dec->pf_decode_video = DecodeVideo;
 
     p_dec->fmt_out.i_cat = p_dec->fmt_in.i_cat;
@@ -502,16 +512,16 @@ static int OpenDecoder(vlc_object_t *p_this)
     /* If the VideoPlayerActivity is not started, MediaCodec opaque
        direct rendering should be disabled since no surface will be
        attached to the JNI. */
-    p_sys->direct_rendering = jni_IsVideoPlayerActivityCreated() && var_InheritBool(p_dec, CFG_PREFIX "dr");
+    p_sys->direct_rendering = jni_IsVideoPlayerActivityCreated(p_sys->object) && var_InheritBool(p_dec, CFG_PREFIX "dr");
     if (p_sys->direct_rendering) {
-        jobject surf = jni_LockAndGetAndroidJavaSurface();
+        jobject surf = jni_LockAndGetAndroidJavaSurface(p_sys->object);
         if (surf) {
             // Configure MediaCodec with the Android surface.
             (*env)->CallVoidMethod(env, p_sys->codec, p_sys->configure, format, surf, NULL, 0);
             if ((*env)->ExceptionOccurred(env)) {
                 msg_Warn(p_dec, "Exception occurred in MediaCodec.configure with an output surface.");
                 (*env)->ExceptionClear(env);
-                jni_UnlockAndroidSurface();
+                jni_UnlockAndroidSurface(p_sys->object);
                 goto error;
             }
             p_dec->fmt_out.i_codec = VLC_CODEC_ANDROID_OPAQUE;
@@ -519,7 +529,7 @@ static int OpenDecoder(vlc_object_t *p_this)
             msg_Warn(p_dec, "Failed to get the Android Surface, disabling direct rendering.");
             p_sys->direct_rendering = false;
         }
-        jni_UnlockAndroidSurface();
+        jni_UnlockAndroidSurface(p_sys->object);
     }
     if (!p_sys->direct_rendering) {
         (*env)->CallVoidMethod(env, p_sys->codec, p_sys->configure, format, NULL, NULL, 0);
@@ -574,6 +584,8 @@ static void CloseDecoder(vlc_object_t *p_this)
     if (!p_sys)
         return;
 
+    var_Destroy (p_dec, "drawable-surfacevalue");
+
     /* Invalidate all pictures that are currently in flight in order
      * to prevent the vout from using destroyed output buffers. */
     if (p_sys->direct_rendering)
@@ -841,7 +853,7 @@ static void GetOutput(decoder_t *p_dec, JNIEnv *env, picture_t **pp_pic, jlong t
                     sar_num = p_dec->fmt_in.video.i_sar_num;
                     sar_den = p_dec->fmt_in.video.i_sar_den;
                 }
-                jni_SetAndroidSurfaceSizeEnv(env, width, height, width, height, sar_num, sar_den);
+                jni_SetAndroidSurfaceSizeEnv(p_sys->object, env, width, height, width, height, sar_num, sar_den);
             } else
                 GetVlcChromaFormat(p_sys->pixel_format, &p_dec->fmt_out.i_codec, &name);
 
@@ -895,7 +907,7 @@ static picture_t *DecodeVideo(decoder_t *p_dec, block_t **pp_block)
         block_Release(p_block);
         if (!p_sys->error_event_sent) {
             /* Signal the error to the Java. */
-            jni_EventHardwareAccelerationError();
+            jni_EventHardwareAccelerationError(p_sys->object);
             p_sys->error_event_sent = true;
         }
         return NULL;
diff --git a/modules/codec/omxil/omxil.c b/modules/codec/omxil/omxil.c
index a9b496a..8001f5e 100644
--- a/modules/codec/omxil/omxil.c
+++ b/modules/codec/omxil/omxil.c
@@ -69,10 +69,10 @@
 #define THREAD_NAME "omxil"
 extern int jni_attach_thread(JNIEnv **env, const char *thread_name);
 extern void jni_detach_thread();
-extern jobject jni_LockAndGetAndroidJavaSurface();
-extern void jni_UnlockAndroidSurface();
-extern void jni_SetAndroidSurfaceSize(int width, int height, int visible_width, int visible_height, int sar_num, int sar_den);
-extern bool jni_IsVideoPlayerActivityCreated();
+extern jobject jni_LockAndGetAndroidJavaSurface(android_surf_value_t *object);
+extern void jni_UnlockAndroidSurface(android_surf_value_t *object);
+extern void jni_SetAndroidSurfaceSize(android_surf_value_t *object, int width, int height, int visible_width, int visible_height, int sar_num, int sar_den);
+extern bool jni_IsVideoPlayerActivityCreated(android_surf_value_t *android_surface);
 #endif
 
 /*****************************************************************************
@@ -1055,6 +1055,15 @@ static int OpenGeneric( vlc_object_t *p_this, bool b_encode )
         return VLC_ENOMEM;
     }
 
+#if defined(USE_IOMX)
+    p_sys->object = var_CreateGetAddress (p_dec, "drawable-surfacevalue");
+    if (!p_sys->object) {
+        msg_Warn(p_dec, "No android_surf_value_t set.");
+        DeinitOmxCore();
+        return VLC_EGENERIC;
+    }
+#endif
+
     /* Initialise the thread properties */
     if(!b_encode)
     {
@@ -1077,7 +1086,7 @@ static int OpenGeneric( vlc_object_t *p_this, bool b_encode )
     p_sys->in.p_fmt = &p_dec->fmt_in;
     OMX_FIFO_INIT (&p_sys->out.fifo, pInputPortPrivate );
 #if defined(USE_IOMX)
-    p_sys->out.b_direct = jni_IsVideoPlayerActivityCreated() && var_InheritBool(p_dec, CFG_PREFIX "dr");
+    p_sys->out.b_direct = jni_IsVideoPlayerActivityCreated(p_sys->object) && var_InheritBool(p_dec, CFG_PREFIX "dr");
 #else
     p_sys->out.b_direct = false;
 #endif
@@ -1912,6 +1921,8 @@ static void CloseGeneric( vlc_object_t *p_this )
     OMX_FIFO_DESTROY( &p_sys->in.fifo );
     OMX_FIFO_DESTROY( &p_sys->out.fifo );
 
+    var_Destroy (p_dec, "drawable-surfacevalue");
+
     free( p_sys );
 }
 
@@ -2088,9 +2099,9 @@ static void HwBuffer_Init( decoder_t *p_dec, OmxPort *p_port )
         goto error;
     }
 
-    surf = jni_LockAndGetAndroidJavaSurface();
+    surf = jni_LockAndGetAndroidJavaSurface(p_dec->p_sys->object);
     if( !surf ) {
-        jni_UnlockAndroidSurface();
+        jni_UnlockAndroidSurface(p_dec->p_sys->object);
         msg_Warn( p_dec, "jni_LockAndGetAndroidJavaSurface failed" );
         goto error;
     }
@@ -2099,7 +2110,7 @@ static void HwBuffer_Init( decoder_t *p_dec, OmxPort *p_port )
     p_port->p_hwbuf->window = p_port->p_hwbuf->native_window.winFromSurface( p_env, surf );
     jni_detach_thread();
 
-    jni_UnlockAndroidSurface();
+    jni_UnlockAndroidSurface(p_dec->p_sys->object);
     if( !p_port->p_hwbuf->window ) {
         msg_Warn( p_dec, "winFromSurface failed" );
         goto error;
@@ -2249,7 +2260,8 @@ static int HwBuffer_AllocateBuffers( decoder_t *p_dec, OmxPort *p_port )
         goto error;
     }
 
-    jni_SetAndroidSurfaceSize( p_port->p_hwbuf->fmt_out.i_width,
+    jni_SetAndroidSurfaceSize( p_dec->p_sys->object,
+                               p_port->p_hwbuf->fmt_out.i_width,
                                p_port->p_hwbuf->fmt_out.i_height,
                                p_port->p_hwbuf->fmt_out.i_visible_width,
                                p_port->p_hwbuf->fmt_out.i_visible_height,
diff --git a/modules/codec/omxil/omxil.h b/modules/codec/omxil/omxil.h
index 651d708..951a7fb 100644
--- a/modules/codec/omxil/omxil.h
+++ b/modules/codec/omxil/omxil.h
@@ -138,4 +138,7 @@ struct decoder_sys_t
     size_t i_nal_size_length; /* Length of the NAL size field for H264 */
     int b_use_pts;
 
+#if defined(USE_IOMX)
+    android_surf_value_t *object;
+#endif
 };
diff --git a/modules/video_output/android/nativewindow.c b/modules/video_output/android/nativewindow.c
index d3f308e..7c90557 100644
--- a/modules/video_output/android/nativewindow.c
+++ b/modules/video_output/android/nativewindow.c
@@ -40,9 +40,9 @@
 #define THREAD_NAME "ANativeWindow"
 extern int jni_attach_thread(JNIEnv **env, const char *thread_name);
 extern void jni_detach_thread();
-extern jobject jni_LockAndGetAndroidJavaSurface();
-extern void jni_UnlockAndroidSurface();
-extern void  jni_SetAndroidSurfaceSize(int width, int height, int visible_width, int visible_height, int sar_num, int sar_den);
+extern jobject jni_LockAndGetAndroidJavaSurface(android_surf_value_t *object);
+extern void jni_UnlockAndroidSurface(android_surf_value_t *object);
+extern void  jni_SetAndroidSurfaceSize(android_surf_value_t *object, int width, int height, int visible_width, int visible_height, int sar_num, int sar_den);
 
 static int Open(vout_window_t *, const vout_window_cfg_t *);
 static void Close(vout_window_t *);
@@ -86,7 +86,7 @@ static int Open(vout_window_t *wnd, const vout_window_cfg_t *cfg)
     }
 
     // Create the native window by first getting the Java surface.
-    jobject javaSurface = jni_LockAndGetAndroidJavaSurface();
+    jobject javaSurface = jni_LockAndGetAndroidJavaSurface(NULL);
     if (javaSurface == NULL)
         goto error;
 
@@ -95,7 +95,7 @@ static int Open(vout_window_t *wnd, const vout_window_cfg_t *cfg)
     p_sys->window = p_sys->native_window.winFromSurface(p_env, javaSurface); // ANativeWindow_fromSurface call.
     jni_detach_thread();
 
-    jni_UnlockAndroidSurface();
+    jni_UnlockAndroidSurface(NULL);
 
     if (p_sys->window == NULL)
         goto error;
@@ -105,7 +105,7 @@ static int Open(vout_window_t *wnd, const vout_window_cfg_t *cfg)
     wnd->sys = p_sys;
 
     // Set the Java surface size.
-    jni_SetAndroidSurfaceSize(cfg->width, cfg->height, cfg->width, cfg->height, 1, 1);
+    jni_SetAndroidSurfaceSize(NULL, cfg->width, cfg->height, cfg->width, cfg->height, 1, 1);
 
     return VLC_SUCCESS;
 
@@ -139,7 +139,7 @@ static int Control(vout_window_t *wnd, int cmd, va_list ap)
         {
             unsigned width = va_arg(ap, unsigned);
             unsigned height = va_arg(ap, unsigned);
-            jni_SetAndroidSurfaceSize(width, height, width, height, 1, 1);
+            jni_SetAndroidSurfaceSize(NULL, width, height, width, height, 1, 1);
             break;
         }
         case VOUT_WINDOW_SET_STATE:
diff --git a/modules/video_output/android/surface.c b/modules/video_output/android/surface.c
index 9ab2f53..88c8d28 100644
--- a/modules/video_output/android/surface.c
+++ b/modules/video_output/android/surface.c
@@ -76,10 +76,10 @@ vlc_module_end()
 #define THREAD_NAME "AndroidSurface"
 extern int jni_attach_thread(JNIEnv **env, const char *thread_name);
 extern void jni_detach_thread();
-extern void *jni_LockAndGetAndroidSurface();
-extern jobject jni_LockAndGetAndroidJavaSurface();
-extern void  jni_UnlockAndroidSurface();
-extern void  jni_SetAndroidSurfaceSize(int width, int height, int visible_width, int visible_height, int sar_num, int sar_den);
+extern void *jni_LockAndGetAndroidSurface(android_surf_value_t *object);
+extern jobject jni_LockAndGetAndroidJavaSurface(android_surf_value_t *object);
+extern void  jni_UnlockAndroidSurface(android_surf_value_t *object);
+extern void  jni_SetAndroidSurfaceSize(android_surf_value_t *object, int width, int height, int visible_width, int visible_height, int sar_num, int sar_den);
 
 // _ZN7android7Surface4lockEPNS0_11SurfaceInfoEb
 typedef void (*Surface_lock)(void *, void *, int);
@@ -125,6 +125,8 @@ struct vout_display_sys_t {
 
     video_format_t fmt;
     bool b_changed_crop;
+
+    android_surf_value_t *object;
 };
 
 struct picture_sys_t {
@@ -136,8 +138,6 @@ struct picture_sys_t {
 static int  AndroidLockSurface(picture_t *);
 static void AndroidUnlockSurface(picture_t *);
 
-static vlc_mutex_t single_instance = VLC_STATIC_MUTEX;
-
 static inline void *LoadSurface(const char *psz_lib, vout_display_sys_t *sys)
 {
     void *p_library = dlopen(psz_lib, RTLD_NOW);
@@ -180,20 +180,19 @@ static int Open(vlc_object_t *p_this)
 
     if (fmt.i_chroma == VLC_CODEC_ANDROID_OPAQUE)
         return VLC_EGENERIC;
-
-    /* */
-    if (vlc_mutex_trylock(&single_instance) != 0) {
-        msg_Err(vd, "Can't start more than one instance at a time");
-        return VLC_EGENERIC;
-    }
-
     /* Allocate structure */
     vout_display_sys_t *sys = (struct vout_display_sys_t*) calloc(1, sizeof(*sys));
     if (!sys) {
-        vlc_mutex_unlock(&single_instance);
         return VLC_ENOMEM;
     }
 
+    sys->object = var_CreateGetAddress (vd, "drawable-surfacevalue");
+    if (!sys->object) {
+        free(sys);
+        msg_Err(vd, "No android_surf_value_t set.");
+        return VLC_EGENERIC;
+    }
+
     /* */
     sys->p_library = LoadNativeWindowAPI(&sys->native_window);
     sys->s_unlockAndPost = (Surface_unlockAndPost)sys->native_window.unlockAndPost;
@@ -202,7 +201,6 @@ static int Open(vlc_object_t *p_this)
     if (!sys->p_library) {
         free(sys);
         msg_Err(vd, "Could not initialize libandroid.so/libui.so/libgui.so/libsurfaceflinger_client.so!");
-        vlc_mutex_unlock(&single_instance);
         return VLC_EGENERIC;
     }
 
@@ -289,7 +287,6 @@ static int Open(vlc_object_t *p_this)
 enomem:
     dlclose(sys->p_library);
     free(sys);
-    vlc_mutex_unlock(&single_instance);
     return VLC_ENOMEM;
 }
 
@@ -301,9 +298,11 @@ static void Close(vlc_object_t *p_this)
     picture_pool_Delete(sys->pool);
     if (sys->window)
         sys->native_window.winRelease(sys->window);
+
+    var_Destroy (vd, "drawable-surfacevalue");
+
     dlclose(sys->p_library);
     free(sys);
-    vlc_mutex_unlock(&single_instance);
 }
 
 static picture_pool_t *Pool(vout_display_t *vd, unsigned count)
@@ -360,9 +359,9 @@ static int  AndroidLockSurface(picture_t *picture)
     sh = sys->fmt.i_height;
 
     if (sys->native_window.winFromSurface) {
-        jobject jsurf = jni_LockAndGetAndroidJavaSurface();
+        jobject jsurf = jni_LockAndGetAndroidJavaSurface(sys->object);
         if (unlikely(!jsurf)) {
-            jni_UnlockAndroidSurface();
+            jni_UnlockAndroidSurface(sys->object);
             return VLC_EGENERIC;
         }
         if (sys->window && jsurf != sys->jsurf) {
@@ -380,9 +379,9 @@ static int  AndroidLockSurface(picture_t *picture)
         // as parameter to the unlock function
         picsys->surf = surf = sys->window;
     } else {
-        picsys->surf = surf = jni_LockAndGetAndroidSurface();
+        picsys->surf = surf = jni_LockAndGetAndroidSurface(sys->object);
         if (unlikely(!surf)) {
-            jni_UnlockAndroidSurface();
+            jni_UnlockAndroidSurface(sys->object);
             return VLC_EGENERIC;
         }
     }
@@ -392,7 +391,7 @@ static int  AndroidLockSurface(picture_t *picture)
         ANativeWindow_Buffer buf = { 0 };
         int32_t err = sys->native_window.winLock(sys->window, &buf, NULL);
         if (err) {
-            jni_UnlockAndroidSurface();
+            jni_UnlockAndroidSurface(sys->object);
             return VLC_EGENERIC;
         }
         info->w      = buf.width;
@@ -411,12 +410,12 @@ static int  AndroidLockSurface(picture_t *picture)
 
     if (info->w != aligned_width || info->h != sh || sys->b_changed_crop) {
         // input size doesn't match the surface size -> request a resize
-        jni_SetAndroidSurfaceSize(aligned_width, sh, sys->fmt.i_visible_width, sys->fmt.i_visible_height, sys->i_sar_num, sys->i_sar_den);
+        jni_SetAndroidSurfaceSize(sys->object, aligned_width, sh, sys->fmt.i_visible_width, sys->fmt.i_visible_height, sys->i_sar_num, sys->i_sar_den);
         // When using ANativeWindow, one should use ANativeWindow_setBuffersGeometry
         // to set the size and format. In our case, these are set via the SurfaceHolder
         // in Java, so we seem to manage without calling this ANativeWindow function.
         sys->s_unlockAndPost(surf);
-        jni_UnlockAndroidSurface();
+        jni_UnlockAndroidSurface(sys->object);
         sys->b_changed_crop = false;
         return VLC_EGENERIC;
     }
@@ -438,7 +437,7 @@ static void AndroidUnlockSurface(picture_t *picture)
 
     if (likely(picsys->surf))
         sys->s_unlockAndPost(picsys->surf);
-    jni_UnlockAndroidSurface();
+    jni_UnlockAndroidSurface(sys->object);
 }
 
 static void Display(vout_display_t *vd, picture_t *picture, subpicture_t *subpicture)
diff --git a/modules/video_output/android/utils.h b/modules/video_output/android/utils.h
index e78c688..bc077ab 100644
--- a/modules/video_output/android/utils.h
+++ b/modules/video_output/android/utils.h
@@ -24,6 +24,7 @@
 # include "config.h"
 #endif
 
+#include <pthread.h>
 #include <android/native_window.h>
 #include <jni.h>
 #include <android/native_window_jni.h>
@@ -44,6 +45,16 @@ typedef struct
     ptr_ANativeWindow_unlockAndPost unlockAndPost;
 } native_window_api_t;
 
+typedef struct android_surf_value_t {
+    pthread_mutex_t vout_android_lock;
+    pthread_cond_t vout_android_surf_attached;
+    void *vout_android_surf;
+    void *vout_android_gui;
+    jobject vout_android_java_surf;
+    jobject vout_android_subtitles_surf;
+    bool vout_video_player_activity_created;
+} android_surf_value_t;
+
 /* Fill the structure passed as parameter and return a library handle
    that should be destroyed with dlclose. */
 void *LoadNativeWindowAPI(native_window_api_t *native);
diff --git a/src/libvlc.c b/src/libvlc.c
index 946ce2e..9d1bcd8 100644
--- a/src/libvlc.c
+++ b/src/libvlc.c
@@ -485,6 +485,9 @@ dbus_out:
     var_Create( p_libvlc, "drawable-clip-right", VLC_VAR_INTEGER );
     var_Create( p_libvlc, "drawable-nsobject", VLC_VAR_ADDRESS );
 #endif
+#ifdef __ANDROID__
+    var_Create( p_libvlc, "drawable-vlcobject", VLC_VAR_ADDRESS);
+#endif
 #if defined (_WIN32) || defined (__OS2__)
     var_Create( p_libvlc, "drawable-hwnd", VLC_VAR_INTEGER );
 #endif
